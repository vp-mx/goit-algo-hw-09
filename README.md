# Домашнє завдання: Жадібні алгоритми та динамічне програмування

## Опис завдання

У цьому завданні ми розглянули два підходи до вирішення задачі розбиття суми на монети: 

1. **Жадібний алгоритм** (`find_coins_greedy`) – вибирає найбільші доступні номінали монет.
2. **Алгоритм динамічного програмування** (`find_min_coins`) – знаходить мінімальну кількість монет для досягнення заданої суми.

Кожен алгоритм реалізований у вигляді функції, яка приймає суму і повертає словник з номіналами монет та їх кількістю.

## Аналіз ефективності

#### Час виконання жадібного алгоритму:
```
Amount:     100 - Time: 0.000017 seconds
Amount:    1000 - Time: 0.000001 seconds
Amount:   10000 - Time: 0.000001 seconds
Amount:  100000 - Time: 0.000001 seconds
Amount: 1000000 - Time: 0.000001 seconds
```

#### Час виконання алгоритму динамічного програмування:
```
Amount:     100 - Time: 0.000057 seconds
Amount:    1000 - Time: 0.000895 seconds
Amount:   10000 - Time: 0.009867 seconds
Amount:  100000 - Time: 0.110955 seconds
Amount: 1000000 - Time: 1.110772 seconds
```

## Висновки

1. **Жадібний алгоритм** працює надзвичайно швидко навіть на великих числах. Його складність – **O(n / min_coin)**, де `min_coin` – найменший номінал монети. У нашому випадку він виконується майже миттєво.

2. **Алгоритм динамічного програмування** має складність **O(n * m)**, де `n` – сума, а `m` – кількість номіналів монет. Він стає помітно повільнішим при великих сумах.

3. **Жадібний алгоритм працює добре, якщо набір монет дозволяє завжди вибрати оптимальне рішення**. У випадку деяких валют (наприклад, якщо набір монет не дозволяє знайти оптимальну комбінацію), жадібний підхід може давати неоптимальні результати.

4. **Динамічне програмування гарантує мінімальну кількість монет**, але значно повільніше.

### Висновок:
- Якщо потрібна **максимальна швидкість**, жадібний алгоритм – найкращий вибір.
- Якщо потрібно **мінімізувати кількість монет** (і точність важливіша за швидкість), варто використовувати алгоритм динамічного програмування.
